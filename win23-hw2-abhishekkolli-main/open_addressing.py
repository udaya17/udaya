from __future__ import annotations

from abc import abstractmethod
from typing import Iterable

from hashtable import BLANK, TOMBSTONE, KT, VT, HashTable


class OpenAddressingHashTable(HashTable):
    """Abstract base class for hashtables which use open addressing to resolve collisions."""

    def items(self) -> Iterable[tuple[KT, VT]]:
        for bucket in self._buckets:
            if bucket is BLANK or bucket is TOMBSTONE:
                continue
            yield bucket

    def __setitem__(self, input_key: KT, input_value: VT):
        index = hash(input_key) % self._capacity

        buckets = self._buckets
        if buckets[index] is not BLANK:
            index_sequence = iter(self._generate_indices(index))
            # TODO: Encountered collision, probe until we find a blank slot or matching key (updating index).
            ...

        if self._load_factor > self._maximum_load_factor:
            # Maximum load factor exceeded, increase size of table
            self._resize()

    def __getitem__(self, search_key: KT) -> VT:
        index = hash(search_key) % self._capacity

        index_sequence = iter(self._generate_indices(start_index=index))
        # TODO: Loop through the indices to find the value matching the search key.
        # Raise KeyError if the search key is not present.
        ...

    def __delitem__(self, key: KT):
        index = hash(key) % self._capacity

        index_sequence = iter(self._generate_indices(start_index=index))
        # TODO: Loop through the indices to find the value matching the key. Replace it with TOMBSTONE.
        # Raise KeyError if the key does not exist.
        ...

        # Notice that since TOMBSTONEs count towards load factor, the load factor hasn't changed.

    @abstractmethod
    def _generate_indices(self, start_index: int) -> Iterable[int]:
        """Generates a sequence of indices using some form of open addressing.

        Parameters
        ----------
        start_index : int
            First index in sequence.

        Yields
        ------
        indices : Iterable[int]
            Sequence of indices generated by the open addressing strategy.
        """
        ...


class LinearProbingHashTable(OpenAddressingHashTable):
    """OpenAddressingHashTable implementation using linear probing."""

    def _generate_indices(self, start_index: int) -> Iterable[int]:
        # TODO: Yield a sequence of indices using linear probing, starting with start_index
        ...


class QuadraticProbingHashTable(OpenAddressingHashTable):
    """OpenAddressingHashTable implementation using quadratic probing."""

    def _generate_indices(self, start_index: int) -> Iterable[int]:
        # TODO: Yield a sequence of indices using linear probing, starting with start_index
        ...
